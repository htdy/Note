1.lambda演算了解一下

数学家希尔伯特倡导无语义的纯符号的形式化系统，艾伦·麦席森.图灵提出了偏硬件的实现的图灵机，阿隆佐·邱奇提出了纯数学演算的lambda演算。

函数式编程语言是基于lambda演算的思想（无语义符号函数式推导）进行编程。面向过程和面向对象的语言则是基于图灵机的思想进行编程。因为现代计算机是冯诺依曼基于图灵机提出的架构，所以函数式编程语言最终是要通过编译器转成面向过程的机器指令。但由于函数编程是偏向纯数学推导的这种思想，也就决定了函数式编程语言的编译器必须负责实现内存回收等面机制。由于lambda演算本身就是一种高阶函数演算，所以闭包也就函数编程语言的天生特性。

函数式编程语言的典型代表是lisp语言，它是基于S表达的一种语法（S表达式是一种括号化的前缀波兰表达式）,而且数据和代码都是用S表达式表示，这也就决定了lisp本身具备元编程的能力。（编译器对元编程无需构建新的语法解析，直接借用对本身语言的语法解析即可）lisp对数据S表达式用引用符标识，一般为反向单引号，代码S表达式可以对数据S表达进行处理，并将输出的S表达式作为代码S表达式进行执行，而这是lisp支持动态特性的天生优势。

人工智能的最初假设便是基于符号的无语义推导，这也是为什么lisp语言被称为人工智能编程语言的原因。

lambda 演算示例：(自然数的定义见皮亚诺公理)

数值计算：(数字只是符号标记，是什么不唯一，重要的是形成基于自然数定义的演算系统)

0 :⇔ λ sz.z



1 = λ sz.s(z)



2 = λ sz.s(s(z))



3 = λ sz.s(s(s(z)))

----------------------------------



S :⇔ λ abc.b(abc)（后继函数）



S0 = (λ abc.b(abc)) (λ sz.z)

= λ bc.b((λ sz.z) bc)

= λ bc.b((λ z.z) c)

= λ bc.b(c)= λ sz.s(z)=1

S1 = (λ abc.b(abc)) (λ sz.s(z))

= λ bc.b((λ sz.s(z)) bc)

= λ bc.b((λ z.b(z)) c)

= λ bc.b(b(c))=λ sz.s(s(z))=2

-----------------------------------

add:

3+5 = 3S5 = (λ sz.s(s(s(z)))) (λ abc.b(abc)) (λ xy.x(x(x(x(x(y))))))

=λ xy.x(x(x(x(x(x(x(x(y))))))))=8

----------------------------------

mutilply:

2 x 3 = mutilply2 3 :⇔ (λ abc.a(bc)) (λ sz.s(s(z))) (λ xy.x(x(x(y))))

= λ c.(λ sz.s(s(z)))((λ xy.x(x(x(y))))c)

= λ cz.((λ xy.x(x(x(y))))c)(((λ xy.x(x(x(y))))c)(z))

= λ cz.(λ y.c(c(c(y)))) (c(c(c(z))))

= λ cz.c(c(c(c(c(c(z)))))) = 6

--------------------------------------

逻辑计算：

TRUE:⇔ λ xy.x
FALSE :⇔ λ xy.y

NOT :⇔ λ a.a (λ bc.c) (λ de.d)



AND :⇔ λ ab.ab (λ xy.y)



OR :⇔ λ ab.a (λ xy.x) b

-----------------------------------

2.闭包的应用场景，与对象的异同

闭包是函数及其附带环境（所谓的环境就是数据），对象是数据和函数的封装。

闭包是函数式编程思想下对于封装这一思想的实现，它以函数为核心。

对象是面向对象的编程思想下的对于封装这一思想的实现，它的核心是数据。（面向对象的编程中函数对象是对象类实现了对函数运算符的重载，对象函数是对象类分装的普通函数）

闭包由于是以函数为核心，所以对数据的操作仅仅暴露了闭包本身作为接口。

对象由于是以数据为核心，所以可以封装并暴露多个对数据进行操作的接口。

闭包示例：

func closure_class() {

    var member1 

    var member2 

    return func(var p, var q){member1+member2+p+q }

}//相当于面向对象中类的定义和封装，member1 ， member2 是成员变量，返回的func相当于类的成员函数。

addobj =  closure_class()//相当于定义一个类的对象实例。

addobj (1,2)//相当于对象实例调用类成员函数。

对象示例：

public class obj_class{

    var member1 

    var member2 

    func add(var p, var q){return member1+member2+p+q }

}

obj = obj_class()

obj.add(1,2)

3..lambda表达式和lambda演算什么关系？

以C++的lambda表达式为例，它是将匿名函数一等公民化（first class），上下文变量闭包化，可以被普通函数作为参数接收（仅限于参数接收，不能返回），而且其本身可以自嵌套（只是很少有人这么写代码而已），但是不可高阶自迭代。（C++可以对上下文变量进行引用形式的闭包化），究其本质只是将基于lambda演算思想的函数式编程闭包转型为匿名函数，方便使用（例如只临时使用一次的函数）。



ref:

https://zhuanlan.zhihu.com/p/30510749

https://zhuanlan.zhihu.com/p/34063805
